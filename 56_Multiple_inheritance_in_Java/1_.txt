ğŸ§© What is Multiple Inheritance?

ğŸ‘‰ Definition:
Multiple inheritance means a class can inherit features (methods and fields) from more than one parent class.

In simple words:

A class having two or more parent classes.

ğŸ”¹ Example (Conceptually)
class A { void show() { System.out.println("A"); } }
class B { void show() { System.out.println("B"); } }
class C extends A, B { }   // âŒ Not allowed in Java


Here, C inherits from both A and B.
But this causes ambiguity â€” because if we call c.show(),
â¡ï¸ The compiler canâ€™t decide whether to call A.show() or B.show().

This is known as the Diamond Problem.

ğŸ’ The Diamond Problem

Letâ€™s visualize it ğŸ‘‡

        A
       / \
      B   C
       \ /
        D


Class B and C inherit from A.

Class D inherits from both B and C.

So D indirectly has two copies of A â†’ leading to ambiguity.

âš ï¸ Why Java Does NOT Support Multiple Inheritance (of classes)

Java designers intentionally disallowed multiple class inheritance to:

Avoid Ambiguity
(diamond problem â€” which parentâ€™s method to call?)

Keep the language simple and predictable

Ensure better code maintainability

Hence:

class C extends A, B { } // âŒ Compile-time error


Youâ€™ll get:

error: '{' expected after class name

âœ… How Java Supports Multiple Inheritance (Through Interfaces)

While Java does not support multiple inheritance of classes,
it does support multiple inheritance of interfaces.

ğŸ”¹ Example
interface A {
    void show();
}

interface B {
    void display();
}

class C implements A, B {
    public void show() {
        System.out.println("Show from A");
    }
    public void display() {
        System.out.println("Display from B");
    }
}


âœ… Works fine!
C inherits behavior from both interfaces A and B.

Reason:

Interfaces only declare methods (no implementation or state).

So, thereâ€™s no ambiguity in inheritance.

â˜• Java 8 and Beyond â€” The Twist

Since Java 8, interfaces can have default and static methods with implementations.

This reintroduces a potential ambiguity â€” but Java handles it clearly.

ğŸ”¹ Example with Default Methods
interface A {
    default void show() {
        System.out.println("A's show");
    }
}

interface B {
    default void show() {
        System.out.println("B's show");
    }
}

class C implements A, B {
    // Must override to resolve conflict
    public void show() {
        System.out.println("C's own show");
        A.super.show(); // optionally call specific parent
    }
}


âœ… Output:

C's own show
A's show

ğŸ§  Javaâ€™s Rule to Resolve Conflict

If a class implements multiple interfaces that have default methods with the same signature,
then the class must override that method to resolve ambiguity.

This is sometimes called the â€œclass winsâ€ or â€œmost specific implementation winsâ€ rule.

ğŸ”¸ Multiple Inheritance in Interfaces

Even interfaces can inherit from multiple interfaces:

interface A {
    void show();
}

interface B {
    void display();
}

interface C extends A, B {
    void print();
}


âœ… This is allowed â€” itâ€™s still not ambiguous because thereâ€™s no implementation conflict.

ğŸ§¾ Summary Table
Concept	Supported in Java?	Notes
Multiple class inheritance	âŒ No	Avoids diamond problem
Multiple interface inheritance	âœ… Yes	Safe, no ambiguity
Multiple inheritance with default methods	âœ… Yes (since Java 8)	Must override if conflict
Constructors in interfaces	âŒ Not allowed	No state, only behavior
Purpose	To allow polymorphism and abstraction without ambiguity	
ğŸ§  In One Line

ğŸ”¸ Java does not allow multiple inheritance of classes to avoid ambiguity.
ğŸ”¸ Java allows multiple inheritance of interfaces, because interfaces define behavior, not state.
ğŸ”¸ From Java 8, if multiple interfaces have default methods with the same signature, the implementing class must override to resolve the conflict.